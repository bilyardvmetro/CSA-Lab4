# Архитектура Компьютера. Лабораторная работа 4

Поленов Кирилл Александрович P3213

## Вариант

```asm | risc | harv | mc | tick | binary | stream | mem | pstr | prob2```

## Язык программирования

### Синтаксис

Язык ассемблерного типа для RISC системы команд

```ebnf
<program> ::= <data_section> <code_section>

<data_section> ::= "." "data" { <data_definition> }
            
<code_section> ::= "." "code" { <instruction> | <macro_definition> | <macro_invocation> }

<instruction> ::=
               "lui" <register> "," { <label> | <string> | <number> }
               | "sw" <register> "," <register> "," { <label> | <string> | <number> } [ <comment> ]
               | "sb" <register> "," <register> "," { <label> | <string> | <number> } [ <comment> ]
               | "lw" <register> "," <register> "," { <label> | <string> | <number> } [ <comment> ]
               | "lb" <register> "," <register> "," { <label> | <string> | <number> } [ <comment> ]
               | "addi" <register> "," <register> "," { <label> | <string> | <number> } [ <comment> ]
               | "ori" <register> "," <register> "," { <label> | <string> | <number> } [ <comment> ]
               | "add" <register> "," <register> "," <register> [ <comment> ]
               | "sub" <register> "," <register> "," <register> [ <comment> ]
               | "mul" <register> "," <register> "," <register> [ <comment> ]
               | "mulh" <register> "," <register> "," <register> [ <comment> ]
               | "div" <register> "," <register> "," <register> [ <comment> ]
               | "rem" <register> "," <register> "," <register> [ <comment> ]
               | "lsl" <register> "," <register> "," <register> [ <comment> ]
               | "lsr" <register> "," <register> "," <register> [ <comment> ]
               | "asr" <register> "," <register> "," <register> [ <comment> ]
               | "and" <register> "," <register> "," <register> [ <comment> ]
               | "or" <register> "," <register> "," <register> [ <comment> ]
               | "xor" <register> "," <register> "," <register> [ <comment> ]
               | "jal" <register> "," <label> [ <comment> ]
               | "jalr" <register> "," <register> "," <label> [ <comment> ]
               | "beq" <register> "," <register> "," <label> [ <comment> ]
               | "bne" <register> "," <register> "," <label> [ <comment> ]
               | "bgt" <register> "," <register> "," <label> [ <comment> ]
               | "ble" <register> "," <register> "," <label> [ <comment> ]
               | "bgtu" <register> "," <register> "," <label> [ <comment> ]
               | "bleu" <register> "," <register> "," <label> [ <comment> ]
               | "halt" [ <comment> ]
               | <label> ":" [ <comment> ]

<macro_definition> ::= "." "macro" <identifier> [ "(" <macro_parameter_list> ")" ] { <instruction> } "." "endmacro" [ <comment> ]

<macro_parameter_list> ::= <identifier> { "," <identifier> }

<macro_invocation> ::= <identifier> [ "(" <macro_argument_list> ")" ] [ <comment> ]

<macro_argument_list> ::= <macro_argument> { "," <macro_argument> }

<macro_argument> ::= <label> | <string> | <number> | <register>

<data_definition> ::= <label> <data_value> [ <comment> ]

<data_value> ::= <string>
               | <number>

<register> ::= "r" <number>

<label> ::= "." <identifier>

<identifier> ::= <letter> { <letter> | <digit> }

<number> ::= <digit> { <digit> }

<string> ::= "\"" { <character> } "\""

<letter> ::= "a" | "b" | "c" | ... | "z"
           | "A" | "B" | "C" | ... | "Z"

<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<character> ::= <any printable ASCII character except quotation mark>

<comment> ::= ";" { <any printable ASCII character> }
```

### Директивы

- `%hi(literal)` - загрузить верхние 20 бит литерала
- `%lo(literal)` - загрузить нижние 12 бит литерала

```asm
.data
    message: "Hello, world!"

.code
    lui bp, %hi(message)      ; загрузить верхние 20 бит адреса метки message
    ori bp, bp, %lo(message)  ; загрузить нижние 12 бит адреса метки message без расширения знака
```

- `.org <address>` - задать начальный адрес секции
- `.data` - создает секцию памяти данных
- `.code` - создает секцию памяти команд
- `.word <value_1>, ..., <value_n>` - выделить машинное слово (4 байта) для каждого значение value, которое
  представляет собой литерал
- `.byte <value_1>, ..., <value_n>` - выделить 1 байт для каждого значения value, которое представляет собой литерал
- `.macro <macros definition> .endmacro` - пара директив задающие пользовательскую макрооперацию

#### Пример макроса

```asm
.data
    message: "Hello, world!"

.code
    .macro load_str_ptr(address)
        lui bp, %hi(address)
        ori bp, bp, %lo(address)
    .endmacro

    .macro load_and_add(rd, rs, offset, value)
        lw rd, rs, offset
        addi rd, rd, value
    .endmacro

    load_str_ptr(message) ; Вызов макроса load_str_ptr с аргументом message

    load_and_add(s1, s2, 0, 5) ; Вызов макроса load_and_add с несколькими аргументами

    halt
```

### Команды

| Команда                     | Описание                                                                                                                          |
|-----------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| `lui <rd>, <k>`             | Загрузить верхние 20 бит литерала в регистр                                                                                       |
| `sw <rs2>, <rs1>, <offset>` | Сохранить слово из rs2 по адресу из rs1 со смещением offset                                                                       |
| `sb <rs2>, <rs1>, <offset>` | Сохранить младший байт rs2 по адресу из rs1 со смещением offset                                                                   |
| `lw <rd>, <rs1>, <offset>`  | Загрузить слово в rd c адреса из rs1 со смещением offset                                                                          |
| `lb <rd>, <rs1>, <offset>`  | Загрузить младший байт в rd с адреса из rs1 со смещением offset                                                                   |
| `addi <rd>, <rs1>, <k>`*    | Сложить содержимое регистра rs1 с литералом k и поместить результат в регистр rd                                                  |
| `add <rd>, <rs1>, <rs2>`    | Сложить содержимое регистра rs1 с содержимым регистра rs2 и поместить результат в регистр rd                                      |
| `sub <rd>, <rs1>, <rs2>`    | Вычесть содержимое регистра rs1 из содержимого регистра rs2 и поместить результат в регистр rd                                    |
| `mul <rd>, <rs1>, <rs2>`    | Умножить содержимое регистра rs1 на содержимое регистра rs2 и поместить результат в регистр rd                                    |
| `mulh <rd>, <rs1>, <rs2>`   | Умножить содержимое регистра rs1 на содержимое регистра rs2 и поместить верхние 32 бита результата в регистр rd                   |
| `div <rd>, <rs1>, <rs2>`    | Разделить содержимое регистра rs1 на содержимое регистра rs2 и поместить результат в регистр rd                                   |
| `rem <rd>, <rs1>, <rs2>`    | Взять остаток от деления содержимого регистра rs1 на содержимое регистра rs2 и поместить результат в регистр rd                   |
| `lsl <rd>, <rs1>, <rs2>`    | Сдвинуть содержимое регистра rs1 влево на количество бит из регистра rs2 и поместить результат в регистр rd                       |
| `lsr <rd>, <rs1>, <rs2>`    | Сдвинуть содержимое регистра rs1 вправо без сохранения знака на количество бит из регистра rs2 и поместить результат в регистр rd |
| `asr <rd>, <rs1>, <rs2>`    | Сдвинуть содержимое регистра rs1 вправо с сохранением знака на количество бит из регистра rs2 и поместить результат в регистр rd  |
| `and <rd>, <rs1>, <rs2>`    | Совершить логическое И содержимого регистра rs1 и содержимого регистра rs2 и поместить результат в регистр rd                     |
| `or <rd>, <rs1>, <rs2>`     | Совершить логическое ИЛИ содержимого регистра rs1 и содержимого регистра rs2 и поместить результат в регистр rd                   |
| `ori <rd>, <rs1>, <k>`      | Совершить логическое ИЛИ содержимого регистра rs1 и литерала k и поместить результат в регистр rd                                 |
| `xor <rd>, <rs1>, <rs2>`    | Совершить исключающее ИЛИ содержимого регистра rs1 и содержимого регистра rs2 и поместить результат в регистр rd                  |
| `jal <rd>, <k>`*1           | Перейти на адрес pc + k, сохранив адрес возврата в регистр rd. Аналог call и jump                                                 |
| `jalr <rd>, <rs1>, <k>`*1   | Перейти на адрес из rs1, сохранив адрес возврата в регистр rd. Аналог call и return                                               |
| `beq <rs1>, <rs2>, <k>`     | Остановить процессор                                                                                                              |
| `bne <rs1>, <rs2>, <k>`     | Перейти на адрес pc + k, если содержимое rs1 равно содержимому rs2                                                                |
| `bgt <rs1>, <rs2>, <k>`     | Перейти на адрес pc + k, если содержимое rs1 не равно содержимому rs2                                                             |
| `ble <rs1>, <rs2>, <k>`     | Перейти на адрес pc + k, если содержимое rs1 больше содержимого rs2. Для сравнения знаковых чисел                                 |
| `bleu <rs1>, <rs2>, <k>`    | Перейти на адрес pc + k, если содержимое rs1 меньше или равно содержимому rs2. Для сравнения знаковых чисел                       |
| `bgtu <rs1>, <rs2>, <k>`    | Перейти на адрес pc + k, если содержимое rs1 больше содержимого rs2. Для сравнения беззнаковых чисел                              |
| `halt`                      | Перейти на адрес pc + k, если содержимое rs1 меньше или равно содержимому rs2. Для сравнения беззнаковых чисел                    |

\* - addi расширяет знак литерала k

\*1 - Если подать регистр `r0` как аргумент `<rd>`, адрес возврата не будет сохранен.

### Стратегия вычислений

- Ассемблер соответствует строгой модели вычислений. Все аргументы вычисляются до применения к ним функций
- Язык не поддерживает выражения включающие в себя несколько ариф./логич. операций. Порядок выполнения операций
  определяет программист

### Области видимости

В языке не существует как таковых областей видимости, однако есть пара моментов:

- Секция данных и команд не имеют прямого доступа друг к другу
- На аппаратном уровне невозможно прочитать команду из памяти команд как данные и наоборот

### Типизация. Виды литералов

- Язык является [**беcтиповым**](https://habr.com/ru/articles/161205/). Все сущности считаются последовательностью бит
  различной длины в пределах машинного слова
- Регистры являются универсальными контейнерами для хранения переменных в виде битовых последовательностей
- Интерпретация содержимого регистров зависит от инструкций, которые к ним применяются. К примеру инструкция `add`
  подразумевает, что операндами являются числа. Инструкция `lw` подразумевает, что один регистров-операндов содержит
  адрес в памяти
- Отсутствие статической проверки типов
- Отсутствие неявных преобразований

Битовые последовательности можно разделить на следующие типы:

- Знаковые числа
- Беззнаковые числа
- Адреса
- Символы
- Строки (последовательности символов)

Литералы соответствуют одному из типов перечисленных выше

## Организация памяти

- Модель памяти соответствует Гарвардской архитектуре
- За управление регистрами отвечает `Register File`
- Обращение к памяти происходит только через регистры
- Регистр `r0` - `Zero register` (значение всегда равно 0)
- Адреса памяти данных и памяти команд представляют собой беззнаковые 32 битные числа
- Модель включает в себя до 32 регистра
- `ALU` не имеет прямого доступа к памяти
- Обращение к памяти происходит только по абсолютному адресу
- Присутствует 3 вида памяти: Память инструкций, Память данных, Память микрокоманд
- Размер машинного слова - **32 бита**
- Инструкции хранятся **только** в памяти команд
- Данные хранятся **только** в памяти данных
- Память Команд
    - Инструкции имеют фиксированную длину - 32 бита
    - Инструкции хранятся в ячейках размером 32 бита
- Память команд
    - Данные хранятся в ячейках размером 32 бита
- Стек не является аппаратной частью и располагается в конце памяти команд. На стек кладутся **только** адреса возврата.
  Для
  аргументов и возвращаемых значений функций следует использовать регистры
  согласно [соглашению](#описание-регистров-и-их-назначение)
- Команды и данные располагаются в памяти согласно формату **little-endian**
- По умолчанию все переменные отображаются в память данных в порядке их инициализации в секции `.data`
- Переменные могут быть отображены на регистры только при явной загрузке в регистры
- Порядок расположения литералов в памяти данных соответствует порядку их объявления в секции `.data`
- Литералы превышающие 32 бита хранятся в памяти следующим образом:

```text
        Data Memory
+-----------------------------+
|      ...                    |
| n       lit_low             |
| n+1     lit_high            |
|      ...                    |
+-----------------------------+
```

Где `lit_low` нижние 32-бита литерала, `lit_high` верхние 32-бита литерала

### Общий вид организации памяти

```text
       Instruction memory
+-----------------------------+
| 00       binary instr       |
| 01       binary instr       |
|      ...                    |
+-----------------------------+
|            Stack            |
+-----------------------------+
| ???      end                |
|      ...                    |
| MAX      begin              |
+-----------------------------+


        Data Memory
+-----------------------------+    +-------+
| 00       data               | <--|IN_BUF |
| 01       data               | <--|OUT_BUF|
|      ...                    |    +-------+
| 10       data               |
| 11       data               |
|      ...                    |
+-----------------------------+

       Microprogram memory
+------------------------------+
| 00       signals             |
| 01       signals             |
|      ...                     |
+------------------------------+
```

### Типы команд

#### Register type (R-type) команды

|  type  | destination register | operation | source register 1 | source register 2 | op extension |
|:------:|:--------------------:|:---------:|:-----------------:|:-----------------:|:------------:|
| 7 bits |        5 bits        |  3 bits   |      5 bits       |      5 bits       |    7 bits    |

`type = 1000000`

| Инструкция | Operation code | Op extension code |
|------------|:--------------:|:-----------------:|
| `add`      |     `001`      |     `0000001`     |
| `sub`      |     `001`      |     `0000010`     |
| `mul`      |     `010`      |     `0000001`     |
| `mulh`     |     `010`      |     `0000010`     |
| `div`      |     `010`      |     `0000011`     |
| `rem`      |     `010`      |     `0000100`     |
| `lsl`      |     `011`      |     `0000001`     |
| `lsr`      |     `011`      |     `0000010`     |
| `asr`      |     `011`      |     `0000011`     |
| `and`      |     `011`      |     `0000100`     |
| `or`       |     `011`      |     `0000101`     |
| `xor`      |     `011`      |     `0000110`     |

#### Immediate type (I-type) команды

|  type  | destination register | operation | source register 1 | immediate value / offset |
|:------:|:--------------------:|:---------:|:-----------------:|:------------------------:|
| 7 bits |        5 bits        |  3 bits   |      5 bits       |         12 bits          |

`type = 0100000`

| Инструкция | Operation code |
|------------|:--------------:|
| `lw`       |     `001`      |
| `lb`       |     `010`      |
| `addi`     |     `011`      |
| `ori`      |     `100`      |
| `jalr`     |     `100`      |
| `halt`     |     `101`      |

#### Store type (S-type) команды

|  type  | offset \[0-4\] bits | operation | source register 1 | source register 2 | offset \[5-11\] bits |
|:------:|:-------------------:|:---------:|:-----------------:|:-----------------:|:--------------------:|
| 7 bits |       5 bits        |  3 bits   |      5 bits       |      5 bits       |        7 bits        |

`type = 0010000`

| Инструкция | Operation code |
|------------|:--------------:|
| `sw`       |     `001`      |
| `sb`       |     `010`      |

#### Branch type (B-type) команды

|  type  | offset \[0-4\] bits | operation | source register 1 | source register 2 | offset \[5-11\] bits |
|:------:|:-------------------:|:---------:|:-----------------:|:-----------------:|:--------------------:|
| 7 bits |       5 bits        |  3 bits   |      5 bits       |      5 bits       |        7 bits        |

`type = 0001000`

| Инструкция | Operation code |
|------------|:--------------:|
| `beq`      |     `001`      |
| `bne`      |     `010`      |
| `bgt`      |     `011`      |
| `ble`      |     `100`      |
| `bgtu`     |     `101`      |
| `bleu`     |     `110`      |

#### Upper type (U-type) команды

|  type  | destination register | immediate value |
|:------:|:--------------------:|:---------------:|
| 7 bits |        5 bits        |     20 bits     |

`type = 0000100`

| Инструкция | Operation code |
|------------|:--------------:|
| `lui`      |       -        |

#### Jump type (J-type) команды

|  type  | destination register | immediate value |
|:------:|:--------------------:|:---------------:|
| 7 bits |        5 bits        |     20 bits     |

`type = 0000010`

| Инструкция | Operation code |
|------------|:--------------:|
| `jal`      |       -        |

#### Бинарные коды регистров

| Регистр | Бин. код |
|:-------:|:--------:|
|  `r0`   | `00000`  |
|  `ra`   | `00001`  |
|  `sp`   | `00010`  |
|  `bp`   | `00011`  |
|  `t0`   | `00100`  |
|  `t1`   | `00101`  |
|  `t2`   | `00110`  |
|  `t3`   | `00111`  |
|  `t4`   | `01000`  |
|  `t5`   | `01001`  |
|  `t6`   | `01010`  |
|  `s0`   | `01011`  |
|  `s1`   | `01100`  |
|  `s2`   | `01101`  |
|  `s3`   | `01110`  |
|  `s4`   | `01111`  |
|  `s5`   | `10000`  |
|  `s6`   | `10001`  |
|  `s7`   | `10010`  |
|  `s8`   | `10011`  |
|  `s9`   | `10100`  |
|  `s10`  | `10101`  |
|  `s11`  | `10110`  |
|  `a0`   | `10111`  |
|  `a1`   | `11000`  |
|  `a2`   | `11001`  |
|  `a3`   | `11010`  |
|  `a4`   | `11011`  |
|  `a5`   | `11100`  |
|  `a6`   | `11101`  |
|  `a7`   | `11110`  |

### Описание регистров и их назначение

- `r0` - системный регистр всегда хранящий 0
- `ra` - адрес возврата
- `sp` - указатель вершины стека
- `bp` - указатель на буфер строки
- `t0-t6` - регистры для временного хранения внутри функции. Caller-saved регистры
- `s0` - может использоваться как указатель на фрейм стека
- `s0, s1-s11` - регистры для сохранения значений перед вызовом функции и восстановить после. Callee-saved регистры
- `a0-a7` - регистры для передачи аргументов/возвращаемых значений в функцию

## Система команд

### Набор инструкций

#### Работа с данными

| Инструкция                  | Тип    | Результат                        | Описание                                                        |
|-----------------------------|--------|----------------------------------|-----------------------------------------------------------------|
| `lui <rd>, <k>`             | U-type | `rd <- k << 12`                  | Загрузить верхние 20 бит литерала в регистр                     |
| `sw <rs2>, <rs1>, <offset>` | S-Type | `mem[rs1 + offset] <- rs2`       | Сохранить слово из rs2 по адресу из rs1 со смещением offset     |
| `sb <rs2>, <rs1>, <offset>` | S-Type | `mem[rs1 + offset] <- rs2& 0xFF` | Сохранить младший байт rs2 по адресу из rs1 со смещением offset |
| `lw <rd>, <rs1>, <offset>`  | I-type | `rd <- mem[rs1 + offset]`        | Загрузить слово в rd c адреса из rs1 со смещением offset        |
| `lb <rd>, <rs1>, <offset>`  | I-type | `rd <- mem[rs1 + offset] & 0xFF` | Загрузить младший байт в rd с адреса из rs1 со смещением offset |

#### Арифметика

| Инструкция                | Тип    | Результат                 | Описание                                                                                      |
|---------------------------|--------|---------------------------|-----------------------------------------------------------------------------------------------|
| `addi <rd>, <rs1>, <k>`*  | I-type | `rd <- rs1 + k`           | Сложить содержимое rs1 с литералом k и поместить результат в регистр rd                       |
| `add <rd>, <rs1>, <rs2>`  | R-type | `rd <- rs1 + rs2`         | Сложить содержимое rs1 с содержимым rs2 и поместить результат в регистр rd                    |
| `sub <rd>, <rs1>, <rs2>`  | R-type | `rd <- rs1 - rs2`         | Вычесть содержимое rs1 из содержимого rs2 и поместить результат в регистр rd                  |
| `mul <rd>, <rs1>, <rs2>`  | R-type | `rd <- rs1 * rs2`         | Умножить содержимое rs1 на содержимое rs2 и поместить результат в регистр rd                  |
| `mulh <rd>, <rs1>, <rs2>` | R-type | `rd <- (rs1 * rs2) >> 32` | Умножить содержимое rs1 на содержимое rs2 и поместить верхние 32 бита результата в регистр rd |
| `div <rd>, <rs1>, <rs2>`  | R-type | `rd <- rs1 / rs2`         | Разделить содержимое rs1 на содержимое rs2 и поместить результат в регистр rd                 |
| `rem <rd>, <rs1>, <rs2>`  | R-type | `rd <- rs1 % rs2`         | Взять остаток от деления содержимого rs1 на содержимое rs2 и поместить результат в регистр rd |

\* - addi расширяет знак литерала k

#### Битовые операции

| Инструкция               | Тип    | Результат          | Описание                                                                                                        |
|--------------------------|--------|--------------------|-----------------------------------------------------------------------------------------------------------------|
| `ori <rd>, <rs1>, <k>`   | I-type | `rd <- rs1 \| k`   | Совершить логическое ИЛИ содержимого rs1 и литерала k и поместить  результат в регистр rd                       |
| `lsl <rd>, <rs1>, <rs2>` | R-type | `rd <- rs1 << rs2` | Сдвинуть содержимое rs1 влево на количество бит из rs2 и поместить результат в регистр rd                       |
| `lsr <rd>, <rs1>, <rs2>` | R-type | `rd <- rs1 >> rs2` | Сдвинуть содержимое rs1 вправо без сохранения знака на количество бит из rs2 и поместить результат в регистр rd |
| `asr <rd>, <rs1>, <rs2>` | R-type | `rd <- rs1 >> rs2` | Сдвинуть содержимое rs1 вправо с сохранением знака на количество бит из rs2 и поместить результат в регистр rd  |
| `and <rd>, <rs1>, <rs2>` | R-type | `rd <- rs1 & rs2`  | Совершить логическое И содержимого rs1 и содержимого rs2 и поместить результат в регистр rd                     |
| `or <rd>, <rs1>, <rs2>`  | R-type | `rd <- rs1 \| rs2` | Совершить логическое ИЛИ содержимого rs1 и содержимого rs2 и поместить результат в регистр rd                   |
| `xor <rd>, <rs1>, <rs2>` | R-type | `rd <- rs1 ^ rs2`  | Совершить исключающее ИЛИ содержимого rs1 и содержимого rs2 и поместить результат в регистр rd                  |

#### Условные и безусловные переходы

| Инструкция               | Тип    | Результат                         | Описание                                                                                                        |
|--------------------------|--------|-----------------------------------|-----------------------------------------------------------------------------------------------------------------|
| `jal <rd>, <k>`*         | J-type | `rd <- pc + 4, pc <- pc + k`      | Перейти на адрес pc + k, сохранив адрес возврата в регистр rd. Аналог call и jump                               |
| `jalr <rd>, <rs1>, <k>`* | I-type | `rd <- pc + 4, pc <- rs1`         | Перейти на адрес из rs1, сохранив адрес возврата в регистр rd. Аналог call и return                             |
| `halt`                   | I-type | -                                 | Остановить процессор                                                                                            |
| `beq <rs1>, <rs2>, <k>`  | B-type | `if rs1 == rs2 then pc <- pc + k` | Перейти на адрес pc + k, если содержимое rs1 равно содержимому rs2                                              |
| `bne <rs1>, <rs2>, <k>`  | B-type | `if rs1 != rs2 then pc <- pc + k` | Перейти на адрес pc + k, если содержимое rs1 не равно содержимому rs2                                           |
| `bgt <rs1>, <rs2>, <k>`  | B-type | `if rs1 > rs2 then pc <- pc + k`  | Перейти на адрес pc + k, если содержимое rs1 больше содержимого rs2. Для сравнения знаковых чисел               |
| `ble <rs1>, <rs2>, <k>`  | B-type | `if rs1 <= rs2 then pc <- pc + k` | Перейти на адрес pc + k, если содержимое rs1 меньше или равно содержимому rs2. Для сравнения знаковых чисел     |
| `bgtu <rs1>, <rs2>, <k>` | B-type | `if rs1 > rs2 then pc <- pc + k`  | Перейти на адрес pc + k, если содержимое rs1 больше содержимого rs2. Для сравнения беззнаковых чисел            |
| `bleu <rs1>, <rs2>, <k>` | B-type | `if rs1 <= rs2 then pc <- pc + k` | Перейти на адрес pc + k, если содержимое rs1 меньше или равно содержимому rs2 . Для сравнения беззнаковых чисел |

\* - Если подать регистр r0 как аргумент rd, адрес возврата не будет сохранен.

### Потактовый цикл исполнения инструкций

### Микрокоманды

## Транслятор

Интерфейс командной строки: translator.go <input_file> <target_code_file> <target_data_file> Реализовано в
модуле: [translator.go](translator.go)

Он выполняет несколько ключевых шагов:

- Удаление комментариев: Функция `remove_comments` удаляет комментарии, что упрощает дальнейшую обработку.

- Преобразование всего исходного кода в токены: Функция `tokenize` преобразует строки в массивы токенов с помощью
  регулярных выражений.

- Преобразование массивов токенов в двоичное представление фиксированной длинны: Функция `convert_tokens_to_binary`
  конвертирует инструкции, а функция `convert_data_tokens_to_binary` - данные

- Запуск трансляции: Основная функция `main` считывает исходный файл, выполняет перевод и записывает результат в целевые
  файлы.

## Система ввода-вывода

- Реализован mem-mapped IO
- Ввод-вывод производится путем обращения к ячейкам `0` и `1` в `Data Memory`
- При обращении к ячейкам `0` и `1` происходит считывание и запись в буфер соответственно
- Для работы с вводом-выводом используются те же команды, что и для обычной работы с памятью: `lw`, `sw`, `lb`, `sb`
- Если в `in` буфере кончаются элементы - процессор прекращает работу

## Модель процессора

### DataPath

### Control Unit

## Тестирование

- Тестирование осуществляется при помощи golden test-ов
