# Архитектура Компьютера. Лабораторная работа 4

Поленов Кирилл Александрович P3213

## Вариант

```asm | risc | harv | mc | tick | binary | stream | mem | pstr | prob2```

---

## Язык программирования

---

### Синтаксис

Язык ассемблерного типа для RISC системы команд

```ebnf
<program> ::= <data_section> <code_section>

<data_section> ::= "." "data" { <data_definition> }
            
<code_section> ::= "." "code" { <instruction> }

<instruction> ::=
               "lui" <register> "," { <label> | <string> | <number> }
               | "sw" <register> "," <register> "," { <label> | <string> | <number> }
               | "sb" <register> "," <register> "," { <label> | <string> | <number> }
               | "lw" <register> "," <register> "," { <label> | <string> | <number> }
               | "lb" <register> "," <register> "," { <label> | <string> | <number> }
               | "addi" <register> "," <register> "," { <label> | <string> | <number> }
               | "ori" <register> "," <register> "," { <label> | <string> | <number> }
               | "add" <register> "," <register> "," <register>
               | "sub" <register> "," <register> "," <register>
               | "mul" <register> "," <register> "," <register>
               | "mulh" <register> "," <register> "," <register>
               | "div" <register> "," <register> "," <register>
               | "rem" <register> "," <register> "," <register>
               | "lsl" <register> "," <register> "," <register>
               | "lsr" <register> "," <register> "," <register>
               | "asr" <register> "," <register> "," <register>
               | "and" <register> "," <register> "," <register>
               | "or" <register> "," <register> "," <register>
               | "xor" <register> "," <register> "," <register>
               | "jal" <register> "," <label>
               | "jalr" <register> "," <register> "," <label>
               | "beq" <register> "," <register> "," <label>
               | "bne" <register> "," <register> "," <label>
               | "bgt" <register> "," <register> "," <label>
               | "ble" <register> "," <register> "," <label>
               | "bgtu" <register> "," <register> "," <label>
               | "bleu" <register> "," <register> "," <label>
               | "halt"
               | <label> ":"


<data_definition> ::= <label> <data_value>

<data_value> ::= <string>
               | <number>

<register> ::= "r" <number>

<label> ::= "." <identifier>

<identifier> ::= <letter> { <letter> | <digit> }

<number> ::= <digit> { <digit> }

<string> ::= "\"" { <character> } "\""

<letter> ::= "a" | "b" | "c" | ... | "z"
           | "A" | "B" | "C" | ... | "Z"

<digit> ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<character> ::= <any printable ASCII character except quotation mark>

<comment> ::= ";" { <any printable ASCII character> }
```

### Команды

- `lui <rd>, <k>` - Загрузить верхние 20 бит литерала в регистр
- `sw <rs2>, <rs1>, <offset>` - Сохранить слово из rs2 по адресу из rs1 со смещением offset
- `sb <rs2>, <rs1>, <offset>` - Сохранить младший байт rs2 по адресу из rs1 со смещением offset
- `lw <rd>, <rs1>, <offset>` - Загрузить слово в rd c адреса из rs1 со смещением offset
- `lb <rd>, <rs1>, <offset>` - Загрузить младший байт в rd с адреса из rs1 со смещением offset
- `addi <rd>, <rs1>, <k>` - Сложить содержимое регистра rs1 с литералом k и поместить результат в регистр rd
- `add <rd>, <rs1>, <rs2>` - Сложить содержимое регистра rs1 с содержимым регистра rs2 и поместить результат в регистр
  rd
- `sub <rd>, <rs1>, <rs2>` - Вычесть содержимое регистра rs1 из содержимого регистра rs2 и поместить результат в регистр
  rd
- `mul <rd>, <rs1>, <rs2>` - Умножить содержимое регистра rs1 на содержимое регистра rs2 и поместить результат в регистр
  rd
- `mulh <rd>, <rs1>, <rs2>` - Умножить содержимое регистра rs1 на содержимое регистра rs2 и поместить верхние 32 бита
  результата в регистр rd
- `div <rd>, <rs1>, <rs2>` - Разделить содержимое регистра rs1 на содержимое регистра rs2 и поместить результат в
  регистр rd
- `rem <rd>, <rs1>, <rs2>` - Взять остаток от деления содержимого регистра rs1 на содержимое регистра rs2 и поместить
  результат в регистр rd
- `lsl <rd>, <rs1>, <rs2>` - Сдвинуть содержимое регистра rs1 влево на количество бит из регистра rs2 и поместить
  результат в регистр rd
- `lsr <rd>, <rs1>, <rs2>` - Сдвинуть содержимое регистра rs1 вправо без сохранения знака на количество бит из регистра
  rs2 и поместить результат в регистр rd
- `asr <rd>, <rs1>, <rs2>` - Сдвинуть содержимое регистра rs1 вправо с сохранением знака на количество бит из регистра
  rs2 и поместить результат в регистр rd
- `and <rd>, <rs1>, <rs2>` - Совершить логическое И содержимого регистра rs1 и содержимого регистра rs2 и поместить
  результат в регистр rd
- `or <rd>, <rs1>, <rs2>` - Совершить логическое ИЛИ содержимого регистра rs1 и содержимого регистра rs2 и поместить
  результат в регистр rd
- `xor <rd>, <rs1>, <rs2>` - Совершить исключающее ИЛИ содержимого регистра rs1 и содержимого регистра rs2 и поместить
  результат в регистр rd
- `jal <rd>, <k>` - Перейти на адрес pc + k, сохранив адрес возврата в регистр rd. Аналог call и jump
- `jalr <rd>, <rs1>, <k>` - Перейти на адрес из rs1, сохранив адрес возврата в регистр rd. Аналог call и return
- `halt`Остановить процессор
- `beq <rs1>, <rs2>, <k>` - Перейти на адрес pc + k, если содержимое rs1 равно содержимому rs2
- `bne <rs1>, <rs2>, <k>` - Перейти на адрес pc + k, если содержимое rs1 не равно содержимому rs2
- `bgt <rs1>, <rs2>, <k>` - Перейти на адрес pc + k, если содержимое rs1 больше содержимого rs2. Для сравнения знаковых
  чисел
- `ble <rs1>, <rs2>, <k>` - Перейти на адрес pc + k, если содержимое rs1 меньше или равно содержимому rs2. Для сравнения
  знаковых чисел
- `bgtu <rs1>, <rs2>, <k>` - Перейти на адрес pc + k, если содержимое rs1 больше содержимого rs2. Для сравнения
  беззнаковых чисел
- `bleu <rs1>, <rs2>, <k>` - Перейти на адрес pc + k, если содержимое rs1 меньше или равно содержимому rs2 . Для
  сравнения беззнаковых чисел

## Организация памяти

---

- Модель памяти соответствует Гарвардской архитектуре
- За управление регистрами отвечает `Register File`
- Обращение к памяти происходит только через регистры
- Регистр r0 - `Zero register` (значение всегда равно 0)
- Адреса памяти данных и памяти команд представляют собой беззнаковые 32 битные числа
- Модель включает в себя до 32 основных регистров
- `ALU` не имеет прямого доступа к памяти
- Обращение к памяти происходит только по абсолютному адресу
- Присутствует 3 вида памяти: Память инструкций, Память данных, Память микрокоманд
- Размер машинного слова - 32 бита
- Память Команд
    - Инструкции имеют фиксированную длину - 32 бита
    - Инструкции хранятся в ячейках размером 32 бита
- Память команд
    - Данные хранятся в ячейках размером 32 бита

```text
       Instruction memory
+-----------------------------+
| 00       binary instr       |
| 01       binary instr       |
|      ...                    |
+-----------------------------+


        Data Memory
+-----------------------------+    +-------+
| 00       data               | <--|IN_BUF |
| 01       data               | <--|OUT_BUF|
|      ...                    |    +-------+
| 10       data               |
| 11       data               |
|      ...                    |
+-----------------------------+

       Microprogram memory
+------------------------------+
| 00       signals             |
| 01       signals             |
|      ...                     |
+------------------------------+
```

### Типы команд

#### Register type (R-type) команды

|  type  | destination register | operation | source register 1 | source register 2 | op extension |
|:------:|:--------------------:|:---------:|:-----------------:|:-----------------:|:------------:|
| 7 bits |        5 bits        |  3 bits   |      5 bits       |      5 bits       |    7 bits    |

`type = 1000000`

#### Immediate type (I-type) команды

|  type  | destination register | operation | source register 1 | immediate value / offset |
|:------:|:--------------------:|:---------:|:-----------------:|:------------------------:|
| 7 bits |        5 bits        |  3 bits   |      5 bits       |         12 bits          |

`type = 0100000`

#### Store type (S-type) команды

|  type  | offset \[0-4\] bits | operation | source register 1 | source register 2 | offset \[5-11\] bits |
|:------:|:-------------------:|:---------:|:-----------------:|:-----------------:|:--------------------:|
| 7 bits |       5 bits        |  3 bits   |      5 bits       |      5 bits       |        7 bits        |

`type = 0010000`

#### Branch type (B-type) команды

|  type  | offset \[0-4\] bits | operation | source register 1 | source register 2 | offset \[5-11\] bits |
|:------:|:-------------------:|:---------:|:-----------------:|:-----------------:|:--------------------:|
| 7 bits |       5 bits        |  3 bits   |      5 bits       |      5 bits       |        7 bits        |

`type = 0001000`

#### Upper type (U-type) команды

|  type  | destination register | immediate value |
|:------:|:--------------------:|:---------------:|
| 7 bits |        5 bits        |     20 bits     |

`type = 0000100`

#### Jump type (J-type) команды

|  type  | destination register | immediate value |
|:------:|:--------------------:|:---------------:|
| 7 bits |        5 bits        |     20 bits     |

`type = 0000010`

#### Бинарные коды регистров

| Регистр | Бин. код |
|:-------:|:--------:|
|  `r0`   | `00000`  |
|  `ra`   | `00001`  |
|  `sp`   | `00010`  |
|  `bp`   | `00011`  |
|  `t0`   | `00100`  |
|  `t1`   | `00101`  |
|  `t2`   | `00110`  |
|  `t3`   | `00111`  |
|  `t4`   | `01000`  |
|  `t5`   | `01001`  |
|  `t6`   | `01010`  |
|  `s0`   | `01011`  |
|  `s1`   | `01100`  |
|  `s2`   | `01101`  |
|  `s3`   | `01110`  |
|  `s4`   | `01111`  |
|  `s5`   | `10000`  |
|  `s6`   | `10001`  |
|  `s7`   | `10010`  |
|  `s8`   | `10011`  |
|  `s9`   | `10100`  |
|  `s10`  | `10101`  |
|  `s11`  | `10110`  |
|  `a0`   | `10111`  |
|  `a1`   | `11000`  |
|  `a2`   | `11001`  |
|  `a3`   | `11010`  |
|  `a4`   | `11011`  |
|  `a5`   | `11100`  |
|  `a6`   | `11101`  |
|  `a7`   | `11110`  |

- `r0` - системный регистр всегда хранящий 0
- `ra` - адрес возврата
- `sp` - указатель вершины стека
- `bp` - указатель на буфер строки
- `t0-t6` - регистры для временного хранения внутри функции. Caller-saved регистры
- `s0` - может использоваться как указатель на фрейм стека
- `s0, s1-s11` - регистры для сохранения значений перед вызовом функции и восстановить после. Callee-saved регистры
- `a0-a7` - регистры для передачи аргументов/возвращаемых значений в функцию

## Система команд

---

### Цикл исполнения

1. Instruction fetch
2. Instruction execution

### Набор инструкций

#### Работа с данными

| Инструкция | Тип    | Operation code | Синтаксис                   | Результат                        | Описание                                                        |
|------------|--------|:--------------:|-----------------------------|----------------------------------|-----------------------------------------------------------------|
| `lui`      | U-type |       -        | `lui <rd>, <k>`             | `rd <- k << 12`                  | Загрузить верхние 20 бит литерала в регистр                     |
| `sw`       | S-Type |     `001`      | `sw <rs2>, <rs1>, <offset>` | `mem[rs1 + offset] <- rs2`       | Сохранить слово из rs2 по адресу из rs1 со смещением offset     |
| `sb`       | S-Type |     `010`      | `sb <rs2>, <rs1>, <offset>` | `mem[rs1 + offset] <- rs2& 0xFF` | Сохранить младший байт rs2 по адресу из rs1 со смещением offset |
| `lw`       | I-type |     `001`      | `lw <rd>, <rs1>, <offset>`  | `rd <- mem[rs1 + offset]`        | Загрузить слово в rd c адреса из rs1 со смещением offset        |
| `lb`       | I-type |     `010`      | `lb <rd>, <rs1>, <offset>`  | `rd <- mem[rs1 + offset] & 0xFF` | Загрузить младший байт в rd с адреса из rs1 со смещением offset |

#### Арифметика

| Инструкция | Тип    | Operation code | Op extension code | Синтаксис                 | Результат                 | Описание                                                                                                        |
|------------|--------|:--------------:|:-----------------:|---------------------------|---------------------------|-----------------------------------------------------------------------------------------------------------------|
| `addi`     | I-type |     `011`      |         -         | `addi <rd>, <rs1>, <k>`   | `rd <- rs1 + k`           | Сложить содержимое регистра rs1 с литералом k и поместить результат в регистр rd                                |
| `add`      | R-type |     `001`      |     `0000001`     | `add <rd>, <rs1>, <rs2>`  | `rd <- rs1 + rs2`         | Сложить содержимое регистра rs1 с содержимым регистра rs2 и поместить результат в регистр rd                    |
| `sub`      | R-type |     `001`      |     `0000010`     | `sub <rd>, <rs1>, <rs2>`  | `rd <- rs1 - rs2`         | Вычесть содержимое регистра rs1 из содержимого регистра rs2 и поместить результат в регистр rd                  |
| `mul`      | R-type |     `010`      |     `0000001`     | `mul <rd>, <rs1>, <rs2>`  | `rd <- rs1 * rs2`         | Умножить содержимое регистра rs1 на содержимое регистра rs2 и поместить результат в регистр rd                  |
| `mulh`     | R-type |     `010`      |     `0000010`     | `mulh <rd>, <rs1>, <rs2>` | `rd <- (rs1 * rs2) >> 32` | Умножить содержимое регистра rs1 на содержимое регистра rs2 и поместить верхние 32 бита результата в регистр rd |
| `div`      | R-type |     `010`      |     `0000011`     | `div <rd>, <rs1>, <rs2>`  | `rd <- rs1 / rs2`         | Разделить содержимое регистра rs1 на содержимое регистра rs2 и поместить результат в регистр rd                 |
| `rem`      | R-type |     `010`      |     `0000100`     | `rem <rd>, <rs1>, <rs2>`  | `rd <- rs1 % rs2`         | Взять остаток от деления содержимого регистра rs1 на содержимое регистра rs2 и поместить результат в регистр rd |

#### Битовые операции

| Инструкция | Тип    | Operation code | Op extension code | Синтаксис                | Результат          | Описание                                                                                                                          |
|------------|--------|:--------------:|:-----------------:|--------------------------|--------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| `lsl`      | R-type |     `011`      |     `0000001`     | `lsl <rd>, <rs1>, <rs2>` | `rd <- rs1 << rs2` | Сдвинуть содержимое регистра rs1 влево на количество бит из регистра rs2 и поместить результат в регистр rd                       |
| `lsr`      | R-type |     `011`      |     `0000010`     | `lsr <rd>, <rs1>, <rs2>` | `rd <- rs1 >> rs2` | Сдвинуть содержимое регистра rs1 вправо без сохранения знака на количество бит из регистра rs2 и поместить результат в регистр rd |
| `asr`      | R-type |     `011`      |     `0000011`     | `asr <rd>, <rs1>, <rs2>` | `rd <- rs1 >> rs2` | Сдвинуть содержимое регистра rs1 вправо с сохранением знака на количество бит из регистра rs2 и поместить результат в регистр rd  |
| `and`      | R-type |     `011`      |     `0000100`     | `and <rd>, <rs1>, <rs2>` | `rd <- rs1 & rs2`  | Совершить логическое И содержимого регистра rs1 и содержимого регистра rs2 и поместить результат в регистр rd                     |
| `or`       | R-type |     `011`      |     `0000101`     | `or <rd>, <rs1>, <rs2>`  | `rd <- rs1 \| rs2` | Совершить логическое ИЛИ содержимого регистра rs1 и содержимого регистра rs2 и поместить результат в регистр rd                   |
| `xor`      | R-type |     `011`      |     `0000110`     | `xor <rd>, <rs1>, <rs2>` | `rd <- rs1 ^ rs2`  | Совершить исключающее ИЛИ содержимого регистра rs1 и содержимого регистра rs2 и поместить результат в регистр rd                  |

#### Условные и безусловные переходы

| Инструкция | Тип    | Operation code | Синтаксис                | Результат                         | Описание                                                                                                        |
|------------|--------|:--------------:|--------------------------|-----------------------------------|-----------------------------------------------------------------------------------------------------------------|
| `jal`*     | J-type |       -        | `jal <rd>, <k>`          | `rd <- pc + 4, pc <- pc + k`      | Перейти на адрес pc + k, сохранив адрес возврата в регистр rd. Аналог call и jump                               |
| `jalr`*    | I-type |     `100`      | `jalr <rd>, <rs1>, <k>`  | `rd <- pc + 4, pc <- rs1`         | Перейти на адрес из rs1, сохранив адрес возврата в регистр rd. Аналог call и return                             |
| `halt`     | I-type |     `101`      | `halt`                   | -                                 | Остановить процессор                                                                                            |
| `beq`      | B-type |     `001`      | `beq <rs1>, <rs2>, <k>`  | `if rs1 == rs2 then pc <- pc + k` | Перейти на адрес pc + k, если содержимое rs1 равно содержимому rs2                                              |
| `bne`      | B-type |     `010`      | `bne <rs1>, <rs2>, <k>`  | `if rs1 != rs2 then pc <- pc + k` | Перейти на адрес pc + k, если содержимое rs1 не равно содержимому rs2                                           |
| `bgt`      | B-type |     `011`      | `bgt <rs1>, <rs2>, <k>`  | `if rs1 > rs2 then pc <- pc + k`  | Перейти на адрес pc + k, если содержимое rs1 больше содержимого rs2. Для сравнения знаковых чисел               |
| `ble`      | B-type |     `100`      | `ble <rs1>, <rs2>, <k>`  | `if rs1 <= rs2 then pc <- pc + k` | Перейти на адрес pc + k, если содержимое rs1 меньше или равно содержимому rs2. Для сравнения знаковых чисел     |
| `bgtu`     | B-type |     `101`      | `bgtu <rs1>, <rs2>, <k>` | `if rs1 > rs2 then pc <- pc + k`  | Перейти на адрес pc + k, если содержимое rs1 больше содержимого rs2. Для сравнения беззнаковых чисел            |
| `bleu`     | B-type |     `110`      | `bleu <rs1>, <rs2>, <k>` | `if rs1 <= rs2 then pc <- pc + k` | Перейти на адрес pc + k, если содержимое rs1 меньше или равно содержимому rs2 . Для сравнения беззнаковых чисел |

\* - Если подать регистр r0 как аргумент rd, адрес возврата не будет сохранен.

## Микрокоманды

---

## Транслятор

---


Интерфейс командной строки: translator.go <input_file> <target_code_file> <target_data_file> Реализовано в
модуле: [translator.go](translator.go)

Он выполняет несколько ключевых шагов:

- Удаление комментариев: Функция `remove_comments` удаляет комментарии, что упрощает дальнейшую обработку.

- Преобразование всего исходного кода в токены: Функция `tokenize` преобразует строки в массивы токенов с помощью
  регулярных выражений.

- Преобразование массивов токенов в двоичное представление фиксированной длинны: Функция `convert_tokens_to_binary`
  конвертирует инструкции, а функция `convert_data_tokens_to_binary` - данные

- Запуск трансляции: Основная функция `main` считывает исходный файл, выполняет перевод и записывает результат в целевые
  файлы.

## Система ввода-вывода

---

- Реализован mem-mapped IO
- Ввод-вывод производится путем обращения к ячейкам `0` и `1` в `Data Memory`
- При обращении к ячейкам `0` и `1` происходит считывание и запись в буфер соответственно
- Для работы с вводом-выводом используются те же команды, что и для обычной работы с памятью: `lw`, `sw`, `lb`, `sb`
- Если в `in` буфере кончаются элементы - процессор прекращает работу

## Модель процессора

---

### DataPath

### Control Unit

## Тестирование

---

- Тестирование осуществляется при помощи golden test-ов
