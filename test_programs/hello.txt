.data
это слово уже в буфере в паскальном формате.
buf: [12, 'h', 'e', 'l', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
out_addr: 0x10

.text
_start:
	; тут прямая, тк нам надо прочитать с адреса метки buf
	lhi r1, buf				; buf[31..12] -> r1[31..12]
	lli r1, buf				; buf[11..0] -> r1[11..0]
	
	; тут косвенная, тк нам надо прочитать с адреса, который лежит по адресу метки out_addr
	lhi r2, out_addr		; out_addr[31..12] -> r2[31..12]
	lli r2, out_addr		; out_addr[11..0] -> r2[11..0]
	lw r2, r2				; mem[out_addr] -> r2
	
	lw r3, r1				; mem[buf] -> r3. Загрузили длины строки (счетчик) в r3
	mv r4, r3				; r3 -> r4
	
loop:
	addi r4, r4, -1			; r4-1 -> r4
	beq end					; if Z=0 goto end
	
	lw r3, r1				; mem[buf] -> r3. Символ в r3
	sw r2, r3				; r3 -> mem[mem[out_addr]]. Вывести символ
	
	jmp loop

end:
	halt






память команд:
<адрес 32 бит>: команда <32 бит>

память команд:
<адрес 32 бит>: данные <32 бит>


виды команд:
-прямая загрузка: <опкод 4 бита> 000 <5 бит регистр> <20 бит литерал/метка в ПАМЯТИ ДАННЫХ (в нее адрес в ПАМЯТИ ДАННЫХ подставится тоже типа литерал)>
-2 регистра: 	  <опкод 4 бита> 001 <5 бит регистр1> <5 бит регистр2> <15 бит нули>
-2 регситра +лит: <опкод 4 бита> 010 <5 бит регистр1> <5 бит регистр2> <15 бит литерал>
-3 регистра:	  <опкод 4 бита> 011 <5 бит регистр1> <5 бит регистр2> <5 бит регистр3> <10 бит нули>
-ветвление:		  <опкод 4 бита> 100 <25 бит адрес в ПАМЯТИ КОМАНД куда прыгнуть>
-безадресная:	  <опкод 4 бита> 101 <25 бит нули>
